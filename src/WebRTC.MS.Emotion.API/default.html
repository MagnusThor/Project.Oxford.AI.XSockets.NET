<!DOCTYPE html>
<html>
<head>
    <title>WebRTC.MS.Emotion.API</title>
    <meta charset="utf-8" />
    <style>
        #photo {
            max-width: 320px;
        }

        .result {
            position: absolute;
            background: rgba(255, 255, 255, 0.5);
        }

            .result pre {
                word-break: break-word;
            }
    </style>
</head>
<body>

    <div id="wrapper">

        <canvas id="canvas" autoplay></canvas>

    </div>
    <button id="btn-emo">Check emotion</button>
    <p>
        ..
    </p>


    <script src="//blueimp.github.io/JavaScript-Canvas-to-Blob/js/canvas-to-blob.js"></script>
    <script src="Scripts/XSockets.latest.js"></script>
    <script>


        attachMediaStream = function (element, stream) {
            if (typeof element.srcObject !== 'undefined') {
                element.srcObject = stream;
            } else if (typeof element.mozSrcObject !== 'undefined') {
                element.mozSrcObject = stream;
            } else if (typeof element.src !== 'undefined') {
                element.src = URL.createObjectURL(stream);
            } else {
                console.log('Error attaching stream to element.');
            }
        };

        var Camera = (function () {

            var ctor = function (srm, w, h, canvas) {
                var self = this;
                this.canvas = canvas;
                this.canvas.width = w || 320;
                this.canvas.height = h || 180;
                this.video = document.createElement("video");
                this.video.autoplay = true;
                this.video.width = w || 320;
                this.video.height = h || 180;
                attachMediaStream(this.video, srm);
                this.context = this.canvas.getContext('2d');
                this.interval = -1;

                window.setInterval(function () {
                    self.context.drawImage(self.video, 0, 0, self.canvas.width, self.canvas.height);
                }, 1000 / 25);
                this.rectangles = [];

            };



            ctor.prototype.takePicture = function (fn, ms) {
                if (!ms) {
                    this.context.drawImage(this.video, 0, 0, this.canvas.width, this.canvas.height);
                    this.canvas.toBlob(function (blob) {
                        fn(blob, URL.createObjectURL(blob));
                    });
                } else {
                    var that = this;
                    this.interval = window.setInterval(function () {
                        that.context.drawImage(that.video, 0, 0, that.canvas.width, that.canvas.height);
                        that.canvas.toBlob(function (blob) {
                            fn(blob, URL.createObjectURL(blob));
                        });
                    }, ms);
                }

            };

            return ctor;

        })();

        var ws, emotionController;

        var camera;
        var main = function (evt) {
            ws = new XSockets.WebSocket("wss://webrtoxfordai.azurewebsites.net:443/", ["emotion"]);
            emotionController = ws.controller("emotion");
            emotionController.on("emotionDetected", function (emotionResult) {
                var parent = document.querySelector("#wrapper");
                var prior = document.querySelectorAll(".result");
                for (var i = 0; i < prior.length; i++) {
                    parent.removeChild(prior[i]);
                };
                emotionResult.forEach(function (result) {
                    var resultDiv = document.createElement("div");
                    resultDiv.classList.add("result");
                    resultDiv.style.top = result.FaceRectangle.Top + "px";
                    resultDiv.style.left = result.FaceRectangle.Left + "px";
                    resultDiv.style.width = result.FaceRectangle.Width + "px";
                    resultDiv.style.height = result.FaceRectangle.Height + "px";
                    var p = document.createElement("pre");
                    p.textContent = JSON.stringify(result.Scores);
                    resultDiv.appendChild(p);
                    parent.appendChild((resultDiv));
                });

            });
            emotionController.onopen = function (ci) {
                console.log("connected to emotionController", ci);
            };
            document.querySelector("#btn-emo").addEventListener("click", function () {
                if (!camera) return;
                camera.takePicture(function (blob) {
                    var arrayBuffer;
                    var fileReader = new FileReader();
                    fileReader.onload = function () {
                        arrayBuffer = this.result;
                        emotionController.invokeBinary("DetectEmotion", arrayBuffer);
                    };
                    fileReader.readAsArrayBuffer(blob);
                });
            });
            navigator.webkitGetUserMedia({ audio: false, video: true },
                function (stream) {
                    camera = new Camera(stream, 640, 480, document.querySelector("canvas"));
                }, function (err) {
                    console.log("gumError", err);
                });
        };
        document.addEventListener("DOMContentLoaded", main);

    </script>
</body>
</html>
